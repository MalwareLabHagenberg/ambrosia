/*
{
function Property(prop, p2){
    this.prop = prop;
    this.p2 = p2;
}

function Comparison(p1, op, p2){
    this.p1 = p1;
    this.op = op;
    this.p2 = p2;
}

function LogicalOperation(p1, op, p2){
    this.p1 = p1;
    this.op = op;
    this.p2 = p2;
}

function UnaryOperator(op, ex){
    this.op = op;
    this.ex = ex;
}

function handleLogicalOperation(ex1, rest){
    if(rest){
        return new LogicalOperation(ex1, rest[0], rest[1]);
    }else{
        return ex1;
    }
}

}
*/


start
  = ws ex1:expression ws rest:(logical_operator start)? 
    { return A.filter.handleLogicalOperation(arguments[0], arguments[1])}

expression
  = "(" exp:start ws ")" 
    { return exp; }
  / cmp:comparison 
    { return cmp; }
  / uo:unary_operator ex:start 
    { return new A.filter.UnaryOperator(uo, ex); }

comparison
  = p1:value ws op:operand ws p2:value
    { return new A.filter.Comparison(p1, op, p2) }
  / "true"
    { return new A.filter.Comparison(1, "EQ", 1); }
  / "false"
    { return new A.filter.Comparison(1, "EQ", 0); }

value
  = property
  / string
  / number

operand
  = '==' { return 'EQ'}
  / '!=' { return 'NEQ' }
  / '>=' { return 'GE' }
  / '>' { return 'G' }
  / '<=' { return 'LE' }
  / '<' { return 'L' }
  / '~' { return 'REGEX' }
  / ':' { return 'IN' }
  / '!:' { return 'NIN' }

unary_operator
  = '!' { return 'NOT' }

logical_operator
  = op:'&&' { return 'AND'}
  / op:'||' { return 'OR' }

property
  = p1:[a-zA-Z_]+ "."? p2:[a-zA-Z_]* 
    { return new A.filter.Property(p1.join(""), p2.join("")) }

string
  = '"' str:[^\"]* '"' 
    { return str.join("") }

number
  = num:[0-9\.]+ { return parseFloat(num.join("")) }

ws
  = [ \t]*
