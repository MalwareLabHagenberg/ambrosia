/*{
A = new Object();
A.filter = new Object();

A.filter.Property = function(prop){
    this.prop = prop;
}

A.filter.Comparison = function(p1, op, p2){
    this.p1 = p1;
    this.op = op;
    this.p2 = p2;
}

A.filter.Static = function(val){
    this.val = val;
}

A.filter.optimizeLogical = function(p1, op, p2){
    var p1_static = p1 instanceof A.filter.Static;
    var p2_static = p2 instanceof A.filter.Static;

    if(op == 'OR'){
        if(p1_static && p1.val == false){
            return p2;
        }else if(p1_static && p1.val == true){
            return new A.filter.Static(true);
        }else if(p2_static && p2.val == false){
            return p1;
        }else if(p2_static && p2.val == true){
            return new A.filter.Static(true);
        }
   }else{
        if(p1_static && p1.val == true){
            return p2;
        }else if(p1_static && p1.val == false){
            return new A.filter.Static(false);
        }else if(p2_static && p2.val == true){
            return p1;
        }else if(p2_static && p2.val == false){
            return new A.filter.Static(false);
        }
    }

    return new A.filter.LogicalOperation(p1, op, p2);
}

A.filter.LogicalOperation = function(p1, op, p2){
    this.p1 = p1;
    this.op = op;
    this.p2 = p2;
}

A.filter.UnaryOperator = function(op, ex){
    this.op = op;
    this.ex = ex;
}

A.filter.handleLogicalOperation = function(ex1, rest){
    if(rest){
        return A.filter.optimizeLogical(ex1, rest[0], rest[1]);
    }else{
        return ex1;
    }
}

A.filter.handleStatement = function(op, block, stmt2){
    var stmt = A.filter.optimizeLogical(op, 'AND', block);
    return new A.filter.optimizeLogical(stmt, 'OR', stmt2);
}
}
*/

start
  = op:operation block:block ";"? ws stmt:start
    { return new A.filter.handleStatement(op, block, stmt); }
  / ws
    { return new A.filter.Static(false); }

block
  = "{" stmt:start "}"
    { return stmt; }
  / ws
    { return new A.filter.Static(true); }

operation
  = ws ex1:expression ws rest:(logical_operator operation)?
    { return A.filter.handleLogicalOperation(arguments[0], arguments[1])}

expression
  = "(" exp:operation ws ")"
    { return exp; }
  / cmp:comparison 
    { return cmp; }
  / uo:unary_operator ex:operation
    { return new A.filter.UnaryOperator(uo, ex); }

comparison
  = p1:value ws op:operand ws p2:value
    { return new A.filter.Comparison(p1, op, p2) }
  / "true"
    { return new A.filter.Static(true); }
  / "false"
    { return new A.filter.Static(false); }

value
  = property
  / string
  / number

operand
  = '==' { return 'EQ'}
  / '!=' { return 'NEQ' }
  / '>=' { return 'GE' }
  / '>' { return 'G' }
  / '<=' { return 'LE' }
  / '<' { return 'L' }
  / '~' { return 'REGEX' }
  / ':' { return 'IN' }
  / '!:' { return 'NIN' }

unary_operator
  = '!' { return 'NOT' }

logical_operator
  = '&&' { return 'AND'}
  / '||' { return 'OR' }

property
  = p:[a-zA-Z_\*\.]+
    { return new A.filter.Property(p.join("")) }

string
  = '"' str:[^\"]* '"' 
    { return str.join("") }

number
  = num:[0-9\.]+ { return parseFloat(num.join("")) }

ws
  = [ \t\n]* "#" [^\n]* "\n"? ws?
  / [ \t\n]* 